@using Blazor.Diagrams.Core.Anchors
@using Blazor.Diagrams.Core.Models.Base
@using Size = Blazor.Diagrams.Core.Geometry.Size

@implements IAsyncDisposable

<MudGrid Spacing="2">
    <MudItem xs="12" md="12">
        <MudPaper Class="pa-4" Elevation="1">
            <MudGrid>
                <MudItem xs="12" md="8">
                    <MudText Typo="Typo.h6" Class="mb-2">Двудольный граф назначений</MudText>
                    <MudText Typo="Typo.body2" Class="mb-0">
                        Слева задачи, справа машины. Соединения показывают назначение задач на машины.
                    </MudText>
                </MudItem>
                <MudItem xs="12" md="4" Class="d-flex justify-end">
                    <div class="d-flex gap-2">
                        <MudButton Variant="Variant.Filled" 
                                  Color="Color.Primary" 
                                  OnClick="ZoomToFit"
                                  StartIcon="@Icons.Material.Filled.FitScreen">
                            Показать весь граф
                        </MudButton>
                    </div>
                </MudItem>
            </MudGrid>
        </MudPaper>
    </MudItem>

    <MudItem xs="12" md="12">
        <MudPaper Class="pa-2" Elevation="1">
            <div class="bipartite-diagram-host" style="height: 500px;">
                @if (Instance != null)
                {
                    <CascadingValue Value="_diagram" IsFixed="true">
                        <DiagramCanvas>
                            <Widgets>
                                <SelectionBoxWidget />
                                <ZoomWidget />
                                <NavigatorWidget Width="220" Height="140" Class="absolute bottom-2 right-2" />
                            </Widgets>
                        </DiagramCanvas>
                    </CascadingValue>
                }
                else
                {
                    <div style="text-align: center; padding: 30px; border: 2px dashed #e0e0e0; border-radius: 8px;">
                        <MudIcon Icon="@Icons.Material.Filled.Grain" Size="MudBlazor.Size.Large" Color="Color.Default" Class="mb-2" />
                        <MudText Typo="Typo.body1" Color="Color.Default" Class="d-block mb-2">
                            Нет данных для отображения графа назначений
                        </MudText>
                        <MudText Typo="Typo.body2" Color="Color.Default" Class="d-block">
                            Создайте задачу, чтобы увидеть граф распределения
                        </MudText>
                    </div>
                }
            </div>
        </MudPaper>
    </MudItem>
</MudGrid>

@code {
    [Parameter] public ProblemInstance? Instance { get; set; }
    [Parameter] public Solution? Solution { get; set; }

    private BlazorDiagram _diagram = null!;
    private readonly Dictionary<int, NodeModel> _taskNodes = new();
    private readonly Dictionary<int, NodeModel> _machineNodes = new();
    private readonly List<EdgeRef> _edges = new();

    private ProblemInstance? _builtForInstance;

    protected override void OnInitialized()
    {
        base.OnInitialized();

        var options = new BlazorDiagramOptions
        {
            AllowMultiSelection = true,
            AllowPanning = true,
            Zoom =
            {
                Enabled = true,
                Minimum = 0.2,
                Maximum = 2.2
            },
            Links =
            {
                DefaultRouter = new NormalRouter(),
                DefaultPathGenerator = new StraightPathGenerator()
            }
        };

        _diagram = new BlazorDiagram(options);
        _diagram.RegisterComponent<NodeModel, BipartiteNodeWidget>();
    }

    protected override void OnParametersSet()
    {
        base.OnParametersSet();
        BuildDiagram();
    }

    private void BuildDiagram(bool forceRebuildNodes = false)
    {
        if (Instance == null)
        {
            _diagram.Nodes.Clear();
            _diagram.Links.Clear();
            _taskNodes.Clear();
            _machineNodes.Clear();
            _edges.Clear();
            _builtForInstance = null;
            return;
        }

        var rebuildNodes = forceRebuildNodes
                           || _builtForInstance != Instance
                           || _taskNodes.Count == 0
                           || _machineNodes.Count == 0;

        if (rebuildNodes)
        {
            _diagram.Nodes.Clear();
            _taskNodes.Clear();
            _machineNodes.Clear();

            var tasks = Instance.Tasks.Values.OrderBy(t => t.Id).ToList();
            var machines = Instance.VirtualMachines.Values.OrderBy(m => m.Id).ToList();

            var nodeWidth = 120d;
            var nodeHeight = 40d;
            var columnGap = 300d;
            var leftX = 40d;
            var rightX = leftX + columnGap;
            var topY = 40d;
            var verticalGap = Math.Max(10d, nodeHeight * 0.35);

            for (var i = 0; i < tasks.Count; i++)
            {
                var y = topY + i * (nodeHeight + verticalGap);
                var node = new NodeModel(new Point(leftX, y))
                {
                    Title = $"T{tasks[i].Id}",
                    Size = new Size(nodeWidth, nodeHeight),
                    Locked = false
                };

                _diagram.Nodes.Add(node);
                _taskNodes[tasks[i].Id] = node;
            }

            for (var i = 0; i < machines.Count; i++)
            {
                var y = topY + i * (nodeHeight + verticalGap);
                var node = new NodeModel(new Point(rightX, y))
                {
                    Title = $"VM{machines[i].Id}",
                    Size = new Size(nodeWidth, nodeHeight),
                    Locked = false
                };

                _diagram.Nodes.Add(node);
                _machineNodes[machines[i].Id] = node;
            }

            _builtForInstance = Instance;
        }

        _diagram.Links.Clear();
        _edges.Clear();

        var assignment = Solution?.Assignment;
        if (assignment == null || assignment.Count == 0)
            return;

        foreach (var (taskId, machineId) in assignment)
        {
            if (!_taskNodes.TryGetValue(taskId, out var leftNode))
                continue;
            if (!_machineNodes.TryGetValue(machineId, out var rightNode))
                continue;

            var link = new LinkModel(new ShapeIntersectionAnchor(leftNode), new ShapeIntersectionAnchor(rightNode));
            _diagram.Links.Add(link);

            var edge = new EdgeRef(taskId, machineId, link);
            _edges.Add(edge);
        }
    }

    private void ZoomToFit()
    {
        if (_diagram != null && Instance != null)
        {
            _diagram.ZoomToFit();
        }
    }

    public ValueTask DisposeAsync()
    {
        return ValueTask.CompletedTask;
    }

    private sealed class EdgeRef
    {
        public EdgeRef(int taskId, int machineId, BaseLinkModel link)
        {
            TaskId = taskId;
            MachineId = machineId;
            Link = link;
        }

        public int TaskId { get; }
        public int MachineId { get; }
        public BaseLinkModel Link { get; }
    }
}